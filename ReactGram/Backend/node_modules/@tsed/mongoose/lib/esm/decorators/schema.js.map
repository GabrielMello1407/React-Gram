{"version":3,"file":"schema.js","sourceRoot":"","sources":["../../../src/decorators/schema.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,eAAe,EAAE,UAAU,EAAE,aAAa,EAAC,MAAM,YAAY,CAAC;AACtE,OAAO,EAAC,gBAAgB,EAAC,MAAM,UAAU,CAAC;AAC1C,OAAO,EAAC,QAAQ,EAAC,MAAM,cAAc,CAAC;AAEtC,OAAO,EAAC,eAAe,EAAC,MAAM,wBAAwB,CAAC;AAEvD,OAAO,EAAC,SAAS,EAAE,cAAc,EAAC,MAAM,uBAAuB,CAAC;AA4BhE,MAAM,UAAU,MAAM,CAAC,UAA0D,EAAE;IACjF,OAAO,CAAC,GAAG,UAAiB,EAAE,EAAE;QAC9B,QAAQ,eAAe,CAAC,UAAU,CAAC,EAAE;YACnC,KAAK,UAAU;gBACb,OAAO,aAAa,CAAC,QAAQ,EAAE,EAAE,UAAU,CAAC,eAAe,EAAE,OAAO,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;YAEtH,KAAK,OAAO;gBACV,MAAM,EAAC,KAAK,EAAC,GAAG,cAAc,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;gBAEvD,gBAAgB,CAAC;oBACf,OAAO,EAAE,KAAK;oBACd,IAAI,EAAE,EAAE;oBACR,UAAU;wBACR,OAAO,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,OAAc,CAAC,CAAC;oBAClD,CAAC;iBACF,CAAC,CAAC;gBACH,MAAM;SACT;IACH,CAAC,CAAC;AACJ,CAAC;AA4BD,MAAM,UAAU,cAAc,CAAC,UAA0D,EAAE;IACzF,OAAO,MAAM,CAAC,OAAc,CAAC,CAAC;AAChC,CAAC","sourcesContent":["import {decoratorTypeOf, StoreMerge, useDecorators} from \"@tsed/core\";\nimport {registerProvider} from \"@tsed/di\";\nimport {Property} from \"@tsed/schema\";\nimport {SchemaTypeOptions} from \"mongoose\";\nimport {MONGOOSE_SCHEMA} from \"../constants/constants\";\nimport {MongooseSchemaOptions} from \"../interfaces/MongooseSchemaOptions\";\nimport {getSchema, getSchemaToken} from \"../utils/createSchema\";\n\n/**\n * Define a class as a Mongoose Schema ready to be used to compose other schemes and models.\n *\n * ### Example\n *\n * ```typescript\n * @MongooseSchema()\n * export class EventSchema {\n *   @Property()\n *   field: string;\n * }\n * ```\n *\n * ### Options\n *\n * - `schemaOptions` (mongoose.SchemaOptions): Option to configure the schema behavior.\n *\n * @param {MongooseSchemaOptions | undefined} options\n * @returns {(target: any) => void}\n * @decorator\n * @mongoose\n * @property\n * @class\n */\nexport function Schema(options?: MongooseSchemaOptions): (target: any) => void;\nexport function Schema(definition: SchemaTypeOptions<any>): Function;\nexport function Schema(options: MongooseSchemaOptions | SchemaTypeOptions<any> = {}) {\n  return (...parameters: any[]) => {\n    switch (decoratorTypeOf(parameters)) {\n      case \"property\":\n        return useDecorators(Property(), StoreMerge(MONGOOSE_SCHEMA, options))(parameters[0], parameters[1], parameters[2]);\n\n      case \"class\":\n        const {token} = getSchemaToken(parameters[0], options);\n\n        registerProvider({\n          provide: token,\n          deps: [],\n          useFactory() {\n            return getSchema(parameters[0], options as any);\n          }\n        });\n        break;\n    }\n  };\n}\n\n/**\n * Define a class as a Mongoose Schema ready to be used to compose other schemes and models.\n *\n * ### Example\n *\n * ```typescript\n * @MongooseSchema()\n * export class EventSchema {\n *   @Property()\n *   field: string;\n * }\n * ```\n *\n * ### Options\n *\n * - `schemaOptions` (mongoose.SchemaOptions): Option to configure the schema behavior.\n *\n * @param {MongooseSchemaOptions | undefined} options\n * @returns {(target: any) => void}\n * @decorator\n * @mongoose\n * @property\n * @class\n */\nexport function MongooseSchema(options?: MongooseSchemaOptions): (target: any) => void;\nexport function MongooseSchema(definition: SchemaTypeOptions<any>): Function;\nexport function MongooseSchema(options: MongooseSchemaOptions | SchemaTypeOptions<any> = {}) {\n  return Schema(options as any);\n}\n"]}