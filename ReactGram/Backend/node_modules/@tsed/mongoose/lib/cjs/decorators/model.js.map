{"version":3,"file":"model.js","sourceRoot":"","sources":["../../../src/decorators/model.ts"],"names":[],"mappings":";;;AAAA,qCAAiD;AACjD,iCAA0C;AAC1C,yCAAgD;AAGhD,yEAAqE;AACrE,sDAAgE;AAChE,wDAAgD;AAChD,0DAAyE;AAEzE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAoCG;AACH,SAAgB,KAAK,CAAC,UAAgC,EAAE;IACtD,OAAO,IAAA,oBAAa,EAAC,CAAC,MAAW,EAAE,EAAE;QACnC,MAAM,EAAC,KAAK,EAAE,cAAc,EAAC,GAAG,IAAA,2BAAa,EAAC,MAAM,EAAE,OAAO,CAAC,CAAC;QAE/D,OAAO,CAAC,kBAAkB,IAAI,IAAA,2BAAkB,EAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC,MAAM,CAAC,CAAC;QAErF,IAAA,qBAAgB,EAAC;YACf,OAAO,EAAE,KAAK;YACd,IAAI,EAAE,EAAE;YACR,UAAU;gBACR,OAAO,IAAA,wBAAS,EAAC,MAAM,EAAE,OAAc,CAAC,CAAC;YAC3C,CAAC;SACF,CAAC,CAAC;QAEH,IAAA,qBAAgB,EAAC;YACf,OAAO,EAAE,MAAM;YACf,IAAI,EAAE,gBAAgB;YACtB,IAAI,EAAE,CAAC,0CAAoB,EAAE,KAAK,CAAC;YACnC,UAAU,CAAC,WAAiC,EAAE,MAAc;gBAC1D,IAAA,kCAAkB,EAAC,MAAM,EAAE,IAAA,6BAAa,EAAC,MAAM,CAAC,CAAC,CAAC;gBAClD,OAAO,IAAA,yBAAW,EAChB,MAAM,EACN,MAAM,EACN,cAAc,EACd,OAAO,CAAC,UAAU,EAClB,OAAO,CAAC,eAAe,EACvB,WAAW,CAAC,GAAG,CAAC,OAAO,CAAC,UAAU,CAAC,CACpC,CAAC;YACJ,CAAC;SACF,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC;AA/BD,sBA+BC","sourcesContent":["import {nameOf, useDecorators} from \"@tsed/core\";\nimport {registerProvider} from \"@tsed/di\";\nimport {DiscriminatorValue} from \"@tsed/schema\";\nimport {Schema} from \"mongoose\";\nimport {MongooseModelOptions} from \"../interfaces/MongooseModelOptions\";\nimport {MONGOOSE_CONNECTIONS} from \"../services/MongooseConnections\";\nimport {createModel, getModelToken} from \"../utils/createModel\";\nimport {getSchema} from \"../utils/createSchema\";\nimport {applySchemaOptions, schemaOptions} from \"../utils/schemaOptions\";\n\n/**\n * Define a class as a Mongoose Model. The model can be injected to the Service, Controller, Middleware, Converters or Filter with\n * `@Inject` annotation.\n *\n * ### Example\n *\n * ```typescript\n * @Model()\n * export class EventModel {\n *   @Property()\n *   field: string;\n * }\n * ```\n *\n * Then inject the model into a service:\n *\n * ```typescript\n * class MyService {\n *    constructor(@Inject(EventModel) eventModel: MongooseModel<EventModel>) {\n *        eventModel.findById().exec();\n *    }\n * }\n * ```\n *\n * ### Options\n *\n * - `schemaOptions` (mongoose.SchemaOptions): Option to configure the schema behavior.\n * - `name` (String): model name.\n * - `collection` (String): collection (optional, induced from model name).\n * - `skipInit` (Boolean): skipInit whether to skip initialization (defaults to false).\n *\n * @param {MongooseModelOptions} options\n * @returns {(target: any) => void}\n * @decorator\n * @mongoose\n * @class\n */\nexport function Model(options: MongooseModelOptions = {}) {\n  return useDecorators((target: any) => {\n    const {token, collectionName} = getModelToken(target, options);\n\n    options.discriminatorValue && DiscriminatorValue(options.discriminatorValue)(target);\n\n    registerProvider({\n      provide: token,\n      deps: [],\n      useFactory() {\n        return getSchema(target, options as any);\n      }\n    });\n\n    registerProvider({\n      provide: target,\n      type: \"mongoose:model\",\n      deps: [MONGOOSE_CONNECTIONS, token],\n      useFactory(connections: MONGOOSE_CONNECTIONS, schema: Schema) {\n        applySchemaOptions(schema, schemaOptions(target));\n        return createModel(\n          target,\n          schema,\n          collectionName,\n          options.collection,\n          options.overwriteModels,\n          connections.get(options.connection)\n        );\n      }\n    });\n  });\n}\n"]}