{"version":3,"file":"createSchema.js","sourceRoot":"","sources":["../../../src/utils/createSchema.ts"],"names":[],"mappings":"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","sourcesContent":["import {cleanObject, nameOf, Store, Type} from \"@tsed/core\";\nimport {deserialize, serialize} from \"@tsed/json-mapper\";\nimport {getProperties, JsonEntityStore} from \"@tsed/schema\";\nimport {pascalCase} from \"change-case\";\nimport mongoose, {Schema, SchemaDefinition, SchemaOptions, SchemaTypeOptions} from \"mongoose\";\nimport {MONGOOSE_SCHEMA, MONGOOSE_SCHEMA_OPTIONS} from \"../constants/constants\";\nimport {MongooseSchemaOptions} from \"../interfaces/MongooseSchemaOptions\";\nimport {MongooseVirtualRefOptions} from \"../interfaces/MongooseVirtualRefOptions\";\nimport {resolveRefType} from \"./resolveRefType\";\nimport {schemaOptions} from \"./schemaOptions\";\n\nexport interface MongooseSchemaMetadata {\n  schema: SchemaDefinition;\n  virtuals: Map<string, MongooseVirtualRefOptions>;\n}\n\n/**\n * @ignore\n */\nfunction setUpSchema({schema, virtuals}: MongooseSchemaMetadata, options?: SchemaOptions) {\n  const mongooseSchema = new mongoose.Schema(schema, options);\n\n  for (const [key, options] of virtuals.entries()) {\n    mongooseSchema.virtual(key, options);\n  }\n\n  return mongooseSchema;\n}\n\n/**\n * @ignore\n */\nfunction isVirtualRef(target: Partial<MongooseVirtualRefOptions>): target is MongooseVirtualRefOptions {\n  return !!(target.ref && target.localField && target.foreignField);\n}\n\nfunction hasVersionField(schema: mongoose.Schema, versionKey?: string | boolean) {\n  // Check if versioning was disabled explicitly\n  if (!versionKey) return false;\n\n  // Check for alternative version field in schema\n  return (versionKey as string) in schema.paths;\n}\n\nexport function createSchema(target: Type<any>, options: MongooseSchemaOptions = {}): mongoose.Schema {\n  const entity = JsonEntityStore.from(target);\n  const schemaOptionsFromStore = entity.store.get(MONGOOSE_SCHEMA_OPTIONS) || {};\n  options.schemaOptions = {...options.schemaOptions, ...schemaOptionsFromStore};\n\n  if (entity.schema.isDiscriminator) {\n    options.schemaOptions!.discriminatorKey = entity.schema.discriminator().propertyName;\n  }\n\n  const schema = setUpSchema(buildMongooseSchema(target), options.schemaOptions);\n\n  schemaOptions(target, options);\n\n  const outputVersionKey = hasVersionField(schema, options.schemaOptions?.versionKey);\n\n  schema.methods.toClass = function toClass() {\n    return deserialize(\n      this.toObject({\n        virtuals: true,\n        versionKey: outputVersionKey,\n        flattenMaps: true\n      }),\n      {\n        type: target,\n        useAlias: false,\n        additionalProperties: true,\n        disabledUnsecureConstructor: false,\n        groups: false\n      }\n    );\n  };\n\n  schema.methods.toJSON = function toJSON(options?: any) {\n    return serialize((this as any).toClass(), options);\n  };\n\n  schema.loadClass(target);\n\n  Store.from(target).set(MONGOOSE_SCHEMA, schema);\n\n  return schema;\n}\n\n/**\n * Get a schema already created. If the schema doesn't exists in registry, it'll be created.\n * @param target\n * @param options\n */\nexport function getSchema(target: Type<any>, options: MongooseSchemaOptions = {}): Schema {\n  const store = Store.from(target);\n\n  if (!store.has(MONGOOSE_SCHEMA)) {\n    createSchema(target, options);\n  }\n\n  return store.get(MONGOOSE_SCHEMA);\n}\n\nexport function getSchemaToken(target: Type<any>, options?: any) {\n  const collectionName = options.name || nameOf(target);\n  const token = Symbol.for(pascalCase(`${collectionName}Schema`));\n\n  return {token, collectionName};\n}\n\n/**\n * @ignore\n */\nexport function buildMongooseSchema(target: any): MongooseSchemaMetadata {\n  const properties = getProperties(target, {withIgnoredProps: true, mongoose: true, groups: false});\n  const schema: MongooseSchemaMetadata = {schema: {}, virtuals: new Map()};\n\n  properties.forEach((propertyMetadata, key) => {\n    // Keeping the Mongoose Schema separate, so it can overwrite everything once schema has been built.\n    const schemaTypeOptions: any = propertyMetadata.store.get(MONGOOSE_SCHEMA) || {};\n\n    if (schemaTypeOptions.schemaIgnore || propertyMetadata.isDiscriminatorKey() || propertyMetadata.isGetterOnly()) {\n      return;\n    }\n\n    if (schemaTypeOptions.ref) {\n      schemaTypeOptions.ref = resolveRefType(schemaTypeOptions.ref as any);\n    }\n\n    if (isVirtualRef(schemaTypeOptions)) {\n      schema.virtuals.set(key as string, schemaTypeOptions);\n\n      return;\n    }\n\n    schema.schema[key as string] = createSchemaTypeOptions(propertyMetadata);\n  });\n\n  return schema;\n}\n\n/**\n * @ignore\n */\nexport function createSchemaTypeOptions<T = any>(propEntity: JsonEntityStore): SchemaTypeOptions<T> | SchemaTypeOptions<T>[] {\n  const key = propEntity.propertyKey;\n  const rawMongooseSchema = propEntity.store.get(MONGOOSE_SCHEMA) || {};\n\n  let schemaTypeOptions: SchemaTypeOptions<T> = {\n    required: propEntity.required\n      ? function () {\n          return propEntity.isRequired(this[key]);\n        }\n      : false\n  };\n\n  if (!propEntity.isClass) {\n    const jsonSchema = propEntity.itemSchema.toJSON();\n    const {minimum: min, maximum: max, minLength: minlength, maxLength: maxlength} = jsonSchema;\n\n    let match: string | RegExp = jsonSchema.pattern;\n    if (match) {\n      match = new RegExp(match);\n    }\n\n    schemaTypeOptions = {\n      ...schemaTypeOptions,\n      type: propEntity.type,\n      match: match as RegExp,\n      min,\n      max,\n      minlength,\n      maxlength,\n      enum: jsonSchema[\"enum\"],\n      default: jsonSchema[\"default\"]\n    };\n  } else if (!rawMongooseSchema.ref) {\n    // References are handled by the final merge\n    schemaTypeOptions = {...schemaTypeOptions, type: getSchema(propEntity.type) as any};\n  }\n\n  schemaTypeOptions = cleanObject({...schemaTypeOptions, ...rawMongooseSchema});\n\n  if (propEntity.isCollection) {\n    if (propEntity.isArray) {\n      return [schemaTypeOptions];\n    }\n    // Can be a Map or a Set;\n    // Mongoose implements only Map;\n    if (propEntity.collectionType !== Map) {\n      throw new Error(`Invalid collection type. ${nameOf(propEntity.collectionType)} is not supported.`);\n    }\n\n    return {type: Map, of: schemaTypeOptions} as unknown as SchemaTypeOptions<T>;\n  }\n\n  return schemaTypeOptions;\n}\n"]}