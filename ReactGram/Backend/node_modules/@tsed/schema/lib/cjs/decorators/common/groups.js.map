{"version":3,"file":"groups.js","sourceRoot":"","sources":["../../../../src/decorators/common/groups.ts"],"names":[],"mappings":";;;AAAA,qCAAmD;AAGnD,yDAAoD;AACpD,iDAA4C;AAE5C;;GAEG;AACH,SAAS,WAAW,CAAC,MAAW,EAAE,MAAsB;IACtD,MAAM,OAAO,GAAyB,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IAEhE,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,UAAU,EAAE,EAAE;QACrC,MAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,KAAK,CAAC,QAAQ,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC,CAAC;QAC1G,MAAM,SAAS,GAAQ,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;QAEzC,SAAS,CAAC,UAAU,CAAC,MAAM,EAAE,UAAU,CAAC,WAAW,CAAC,CAAC;IACvD,CAAC,CAAC,CAAC;AACL,CAAC;AAcD,SAAgB,MAAM,CAAC,GAAG,MAAW;IACnC,OAAO,IAAA,2BAAY,EAAC,CAAC,MAAM,EAAE,EAAE;QAC7B,QAAQ,MAAM,CAAC,aAAa,EAAE;YAC5B,KAAK,qBAAc,CAAC,KAAK;gBACvB,WAAW,CAAC,MAAM,EAAE,MAAwB,CAAC,CAAC;gBAC9C,MAAM;YACR,KAAK,qBAAc,CAAC,IAAI;gBACtB,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,QAAQ,EAAE,CAAC,IAAa,EAAE,WAAqB,EAAE,EAAE;oBACzE,IAAI,CAAC,IAAI,EAAE;wBACT,IAAI,IAAA,yBAAW,EAAC,MAAM,EAAE,WAAW,CAAC,EAAE;4BACpC,OAAO,IAAI,CAAC;yBACb;qBACF;oBAED,OAAO,IAAI,CAAC;gBACd,CAAC,CAAC,CAAC;gBACH,MAAM;YACR,KAAK,qBAAc,CAAC,KAAK;gBACvB,IAAI,UAAU,GAAG,EAAE,CAAC;gBAEpB,IAAI,MAAM,CAAC,MAAM,IAAI,CAAC,IAAI,IAAA,cAAO,EAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;oBAC5C,UAAU,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;oBACvB,MAAM,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;iBACpB;gBAEA,MAA6B,CAAC,SAAS,CAAC,MAAM,GAAG,MAAM,CAAC;gBACxD,MAA6B,CAAC,SAAS,CAAC,UAAU,GAAG,UAAU,CAAC;gBACjE,MAAM;SACT;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AA9BD,wBA8BC","sourcesContent":["import {DecoratorTypes, isArray} from \"@tsed/core\";\nimport type {JsonClassStore} from \"../../domain/JsonClassStore\";\nimport type {JsonParameterStore} from \"../../domain/JsonParameterStore\";\nimport {matchGroups} from \"../../utils/matchGroups\";\nimport {JsonEntityFn} from \"./jsonEntityFn\";\n\n/**\n * @ignore\n */\nfunction groupsClass(groups: any, entity: JsonClassStore) {\n  const entries: [string, string[]][] = Object.entries(groups[0]);\n\n  entity.children.forEach((propEntity) => {\n    const groups = entries.filter(([, props]) => props.includes(propEntity.propertyName)).map(([key]) => key);\n    const decorator: any = Groups(...groups);\n\n    decorator(propEntity.target, propEntity.propertyKey);\n  });\n}\n\n/**\n * Apply groups validation strategy\n *\n * @decorator\n * @validation\n * @swagger\n * @schema\n * @input\n */\nexport function Groups<T>(groupsDefinition: Record<string, (keyof T)[]>): ClassDecorator;\nexport function Groups<T>(groupName: string, groups: string[]): ParameterDecorator;\nexport function Groups(...groups: string[]): Function;\nexport function Groups(...groups: any): any {\n  return JsonEntityFn((entity) => {\n    switch (entity.decoratorType) {\n      case DecoratorTypes.CLASS:\n        groupsClass(groups, entity as JsonClassStore);\n        break;\n      case DecoratorTypes.PROP:\n        entity.schema.$hooks.on(\"groups\", (prev: boolean, givenGroups: string[]) => {\n          if (!prev) {\n            if (matchGroups(groups, givenGroups)) {\n              return true;\n            }\n          }\n\n          return prev;\n        });\n        break;\n      case DecoratorTypes.PARAM:\n        let groupsName = \"\";\n\n        if (groups.length == 2 && isArray(groups[1])) {\n          groupsName = groups[0];\n          groups = groups[1];\n        }\n\n        (entity as JsonParameterStore).parameter.groups = groups;\n        (entity as JsonParameterStore).parameter.groupsName = groupsName;\n        break;\n    }\n  });\n}\n"]}